using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;

// Major Project
// Programmer:       Robert J. Sutton
// Course:           CSC450, Section 1, Fall 2015
// Date:             16.11.2015
// Description:      This programme is designed to provide a simple, but as true to life as
//                   possible traffic model to answer the question:
//
//                   Does excessive lane changing on multilane motorways cause delays?
//              
//

namespace Project_1
{
    public partial class Form1 : Form
    {
        const decimal TIMESTEP = 0.01m;    // Run in 0.01 second time intervals.
        const decimal MAXDECEL = -5.19m;   // Value derived from NJ Driver Manual.
        //const decimal MAXDECEL = -40.00m;  // An arbirtary value I chose
        car[] cars = new car[10000];
        decimal[] vDesired = new decimal[10000];
        decimal[] BAC = new decimal[10000];
        StreamReader sr= new StreamReader("v.csv");
        StreamReader sr1 = new StreamReader("bac.csv");
        

        /************ Constant factors from Mehar et al (2013)****************/
        /***** Used to calculate acceleration as a function of velocity ******/
        const decimal A = 1.915m;                                            //
        const decimal B = -0.0375m;                                          //
        const decimal C = 3.705m;                                            //
        const decimal D = -0.0525m;                                          //
        /*********************************************************************/

        public Form1()
        {
            InitializeComponent();
        }

        private void btnQuit_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void btnGo_Click(object sender, EventArgs e)
        {
            decimal t = 0;
            int ID = 0;
            Bitmap BM = new Bitmap(pictureBox1.ClientSize.Width, pictureBox1.ClientSize.Height);
            pictureBox1.Image = BM;

            string trash = sr.ReadLine();      // Trash column titles from R code.
            trash = sr1.ReadLine();

            // Read data arrays generated by R programme
            for (int i = 0; i < 10000; i++)
            {
                vDesired[i] = Convert.ToDecimal(sr.ReadLine());
                string line = sr1.ReadLine();
                if (line.IndexOf('E') > 0 || line.IndexOf('e') > 0) BAC[i] = 0;  // Small quantities in e-xx format
                else BAC[i] = Convert.ToDecimal(line);
                if (BAC[i] < 0) BAC[i] = 0;             // BAC cannot be negative.
            }

            while (1 == 1)
            {
                // Create a car at x = 0 at 3 second intervals.
                if (Math.Abs(t / 3 - Math.Floor(t / 3)) < 0.001m)
                {
                    cars[ID] = new car();
                    initCar(cars[ID], ID, 0);
                    ID++;
                }

                // Let's move the cars
                for (int i = 0; i < ID; i++)
                {
                    cars[i].x += TIMESTEP * cars[i].v;
                    cars[i].v += TIMESTEP * cars[i].a;

                    // Cars may not go backwards.
                    if (cars[i].v < 0)
                    {
                        cars[i].v = 0;
                        cars[i].a = 0;
                    }
                    if (i != 0)
                    {
                        cars[i].headway = cars[cars[i].precedingCar].x - cars[i].x - 5;

                        // Accident
                        if (cars[i].headway < 0)
                        {
                            accident(i, cars[i].precedingCar, cars[i].x);
                        }
                        else
                        {
                            if (cars[i].headway < 2 / cars[i].aggFac * cars[i].v || cars[i].v > cars[i].vDesired)
                            {
                                if (cars[i].brake && t >= cars[i].deTime + cars[i].reactTime)
                                {
                                    if (cars[i].headway < 2 / cars[i].aggFac * cars[i].v)
                                    {
                                        cars[i].a = 300 * (cars[i].headway - 2 / cars[i].aggFac * cars[i].v) / cars[i].headway;
                                    }
                                    else if (cars[i].v > cars[i].vDesired)
                                    {
                                        cars[i].a = 300 * (cars[i].vDesired - cars[i].v) / cars[i].vDesired;
                                    }
                                    if (cars[i].a < MAXDECEL) cars[i].a = MAXDECEL;
                                }
                                else if (!cars[i].brake)
                                {
                                    cars[i].brake = true;
                                    cars[i].gas = false;
                                    cars[i].deTime = t;
                                }
                            }
                            else if (cars[i].headway > 2 / cars[i].aggFac * cars[i].v + 10 && cars[i].v < cars[i].vDesired)
                            {
                                if (cars[i].gas && t >= cars[i].acTime + cars[i].reactTime)
                                {
                                    cars[i].a = aAve(cars[i].v);
                                    if (cars[i].a > aMax(cars[i].v)) cars[i].a = aMax(cars[i].v);
                                }
                                else if (!cars[i].gas)
                                {
                                    cars[i].brake = false;
                                    cars[i].gas = true;
                                    cars[i].acTime = t;
                                }
                            }
                            else
                            {
                                cars[i].brake = false;
                                cars[i].gas = false;
                                cars[i].a = 0;
                            }
                        }

                        // Emergency stop situation
                        if ((cars[i].headway < 600 && cars[cars[i].precedingCar].v < 0.75m * cars[i].v) || cars[cars[i].precedingCar].emergStop)
                        {
                            if (!cars[i].emergStop) cars[i].esTime = t;
                            cars[i].emergStop = true;
                        }
                        if (cars[i].emergStop && t > cars[i].esTime + cars[i].reactTime)
                        {
                            cars[i].a = MAXDECEL;
                        }
                        if (cars[i].v <= cars[cars[i].precedingCar].v) cars[i].emergStop = false;
                    }

                    // Draw the car
                    int offset = 0;
                    switch (cmbDisplay.Text)
                    {
                        case "  0 to   1 km":
                            offset = 0;
                            lblStart.Text = "km 0 ";
                            lblEnd.Text = "km 1 ";
                            break;
                        case "  1 to   2 km":
                            offset = 1000;
                            lblStart.Text = "km 1 ";
                            lblEnd.Text = "km 2 ";
                            break;
                        case "  2 to   3 km":
                            offset = 2000;
                            lblStart.Text = "km 2 ";
                            lblEnd.Text = "km 3 ";
                            break;
                        case "  3 to   4 km":
                            offset = 3000;
                            lblStart.Text = "km 3 ";
                            lblEnd.Text = "km 4 ";
                            break;
                        case "  4 to   5 km":
                            offset = 4000;
                            lblStart.Text = "km 4 ";
                            lblEnd.Text = "km 5 ";
                            break;
                        case "  5 to   6 km":
                            offset = 5000;
                            lblStart.Text = "km 5 ";
                            lblEnd.Text = "km 6 ";
                            break;
                        case "  6 to   7 km":
                            offset = 6000;
                            lblStart.Text = "km 6 ";
                            lblEnd.Text = "km 7 ";
                            break;
                        case "  7 to   8 km":
                            offset = 7000;
                            lblStart.Text = "km 7 ";
                            lblEnd.Text = "km 8 ";
                            break;
                        case "  8 to   9 km":
                            offset = 8000;
                            lblStart.Text = "km 8 ";
                            lblEnd.Text = "km 9 ";
                            break;
                        case "  9 to 10 km":
                            offset = 9000;
                            lblStart.Text = "km 9 ";
                            lblEnd.Text = "km 10 ";
                            break;
                        case "10 to 11 km":
                            offset = 10000;
                            lblStart.Text = "km 10 ";
                            lblEnd.Text = "km 11 ";
                            break;
                        case "11 to 12 km":
                            offset = 1000;
                            lblStart.Text = "km 11 ";
                            lblEnd.Text = "km 12 ";
                            break;
                        default:
                            offset = 0;
                            lblStart.Text = "km 0 ";
                            lblEnd.Text = "km 1 ";
                            break;
                    }
                    lblStart.Refresh();
                    lblEnd.Refresh();

                    int xPlot = Convert.ToInt32(cars[i].x);
                    xPlot -= offset;
                    for (int x = xPlot; x >= xPlot - 5; x--)
                    {
                        if (x > 0 && x < 1000)
                        {
                            for (int y = 16; y < 19; y++)
                            {
                                BM.SetPixel(x, y, Color.LightGreen);
                            }
                        }
                    }
                    for (int x = xPlot - 6; x >= xPlot - 11; x--)
                    {
                        if (x > 0 && x < 1000)
                        {
                            for (int y = 16; y < 19; y++)
                            {
                                BM.SetPixel(x, y, SystemColors.ControlDarkDark);
                            }
                        }
                    }
                }
                pictureBox1.Refresh();

                string timer = t.ToString();
                if (t < 0.001m) timer += ".00";
                lblClock.Text = "SIMULATED TIME = " + timer;
                lblClock.Refresh();
                t += TIMESTEP;
            }
        }

        public decimal aAve(decimal v)
        {
            return A * Convert.ToDecimal(Math.Exp(Convert.ToDouble(B * v)));
        }

        public decimal aMax(decimal v)
        {
            return C + D * v;
        }

        public void initCar(car auto, int ID, decimal x)
        {
            auto.ID = ID;
            auto.x = x;
            //auto.vDesired = 30;
            auto.BAC = 0;

            int j = ID;
            while (j >= 10000) j -= 10000;
            auto.vDesired = vDesired[j];  
            if (cbAlcohol.Checked) auto.BAC = BAC[j];
            auto.a = 0;
            if (ID == 0)
            {
                auto.precedingCar = -1;  // The first car has no preceding car;
                auto.headway = 1000;     // arbitrarily set its headway to 1 km.
            }
            else
            {
                // Find the preceding car
                decimal xMin = x + 1000;
                for (int i = 0; i < ID; i++)
                {
                    if (cars[i].x > x)
                    {
                        if (cars[i].x < xMin)
                        {
                            auto.precedingCar = i;
                            auto.headway = cars[i].x - x - 5;  // 5 meters for the car length
                            cars[i].followingCar = ID;         // We're following the preceding car
                            xMin = cars[i].x;
                        } // End if
                    } // End if
                } // End for
            } // End else 

            auto.v = auto.vDesired;
            auto.exists = true;
            auto.aggFac = 1;          // 1 = no aggression
            if (cbAggressive.Checked)
            {
                Random random = new Random();
                int randomNumber =  random.Next(0, 100);
                auto.aggFac += Convert.ToDecimal(randomNumber) / 200;  // 
                auto.aggFac *= (1 + 10 * auto.BAC);
            }
            auto.reactTime = 1.5m;    // From the New Jersey Driver Manual, Chapter 5
            //auto.reactTime = 0.5375m; // Average Baseline from Austin (2009)
            //auto.reactTime = 0.25m;   // An arbitrary value I chose.
            double martini = 1 + Convert.ToDouble(auto.BAC);
            auto.reactTime *= Convert.ToDecimal(Math.Pow(martini, 2));
            auto.brake = false;
            auto.gas = false;
            auto.acTime = 0;
            auto.deTime = 0;
            auto.crashed = false;
            auto.emergStop = false;            
        } // End Method

        public void accident(int vehicle1, int vehicle2, decimal x)
        {
            cars[vehicle1].v = 0;
            cars[vehicle1].a = 0;
            cars[vehicle1].crashed = true;
            cars[vehicle2].v = 0;
            cars[vehicle2].a = 0;
            cars[vehicle2].crashed = true;
            lblAccident.Visible = true;
            lblAccident.Refresh();
        }
    }

    public class car
    {
        public int ID;             // Unique identifier, incremented by 1 for each agent created
        public decimal x;          // Position of the car in meters
        public decimal v;          // Velocity of the car (meters/second in +x direction)
        public decimal a;          // Change in velocity of car (meters/sec/sec)
        public int precedingCar;   // The car ahead
        public int followingCar;   // The car behind
        public bool exists;        // Set to true when agent is created, false when destroyed
        public decimal BAC;        // Driver's blood alcohol content (% w/v)
        public decimal aggFac;     // Driver's aggression factor
        public decimal reactTime;  // Driver's reaction time (seconds)
        public decimal vDesired;   // Driver's desired velocity
        public decimal headway;    // Distance between the car and the rear of the preceding car (meters)
        public bool brake;         // Driver decelerates
        public bool gas;           // Driver accelerates
        public decimal deTime;     // Time driver needs to start decelerating
        public decimal acTime;     // Time driver has clearance to accelerate
        public bool crashed;       // Has the car been involved in an accident?
        public bool emergStop;     // The car in front is stopped.
        public decimal esTime;     // Time driver needs to slow down or stop for stopped traffic ahead.

    }
}
